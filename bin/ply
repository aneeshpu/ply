#!/usr/bin/env python
import os
import sys

import ply
from ply import git


def die(msg):
    print msg
    sys.exit(1)


def usage():
    die("usage: ply <cmd>")


def do_link(*args):
    """Link a working repo to a patch repo."""
    if not args:
        die("ply link [-f] <patch-repo-path>")

    patch_repo_path = args[0]
    force = ('--force' in args) or ('-f' in args)

    working_repo = ply.WorkingRepo('.')

    try:
        working_repo.link_to_patch_repo(patch_repo_path, force=force)
    except ply.exc.AlreadyLinkedToPatchRepo:
        die("Already linked to '%s', use --force to overwrite."
            % patch_repo_path)
    except ply.exc.PathNotFound:
        die("'%s' does not exist" % patch_repo_path)


def do_init(*args):
    """Link a working repo to a patch repo."""
    if not args:
        die("ply init <patch-repo-path>")

    patch_repo_path = args[0]

    patch_repo = ply.PatchRepo(patch_repo_path)
    patch_repo.init()


def do_resolve():
    """Mark conflicts for a patch as resolved and continue applying the rest
    of the patches.

    Steps:

        1. Fix the conflicting lines.
        2. Add the files to the index.
        3. Run ply resolve
            a. This runs git am --resolve
            b. Creates revised patch
            c. Copies this revised patch over to patch repo.
            d. Continues applying the rest of the patches
    """
    working_repo = ply.WorkingRepo('.')
    working_repo.resolve()


def do_save(*args):
    """Saves last commit as a new patch in the patch-repo."""
    quiet = ('--quiet' in args) or ('-q' in args)
    working_repo = ply.WorkingRepo('.')
    working_repo.save(quiet=quiet)


def do_rollback():
    """Rollback all patches."""
    working_repo = ply.WorkingRepo('.')
    working_repo.rollback()


def do_restore():
    """Apply the patch series to the the current branch of the
    working-repo.
    """
    working_repo = ply.WorkingRepo('.')
    working_repo.restore()


def main():
    if len(sys.argv) < 2:
        usage()

    cmd = sys.argv[1]
    func = globals().get('do_%s' % cmd)
    if func:
        func(*sys.argv[2:])
    else:
        die("command '%s' not found" % cmd)


if __name__ == "__main__":
    main()
