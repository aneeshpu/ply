#!/usr/bin/env python
import os
import sys

import ply
from ply import git


def die(msg):
    print msg
    sys.exit(1)


def usage():
    cmds = [x.replace('do_', '')
            for x in globals().keys() if x.startswith('do_')]
    die("usage: ply <%s>" % '|'.join(sorted(cmds)))


def die_on_conflicts():
    print "Patch did not apply cleanly. To fix:"
    print
    print "\t1) Fix conflicts in affected files"
    print "\n\t2) `git add` affected files"
    print "\n\t3) Run `ply resolve` to refresh the patch and"\
          " apply the rest\n\t   of the patches in the series."
    sys.exit(1)


def do_init(_, *args):
    """Link a working repo to a patch repo."""
    if not args:
        die("ply init <patch-repo-path>")

    patch_repo_path = args[0]
    patch_repo = ply.PatchRepo(patch_repo_path)
    patch_repo.initialize()


def do_restore(working_repo, *args):
    """Apply the patch series to the the current branch of the working-repo.

    --resolved: mark conflicts for a patch as resolved and continue applying
                the rest of the patches in the series.

    -v: verbose mode
    """
    quiet = '-v' not in args
    resolved = '--resolved' in args

    try:
        if resolved:
            working_repo.resolve(quiet=quiet)
        else:
            working_repo.restore(quiet=quiet)
    except ply.git.exc.PatchDidNotApplyCleanly:
        die_on_conflicts()


def do_save(working_repo, *args):
    """Saves last commit as a new patch in the patch-repo.

    -v: verbose mode

    --prefix: optional subdirectory in the patch-repo in which to drop the
              newly minted patch

    since: optional revision to bookend where patches begin. The revision
             should be the one BEFORE the first patch (e.g. uses
             format-patches 'since' semantics)
    """
    quiet = '-v' not in args

    prefix = None
    positional = []
    for arg in args:
        if arg.startswith('--prefix='):
            prefix = arg.replace('--prefix=', '')
        else:
            positional.append(arg)

    try:
        since = positional[0]
    except IndexError:
        die("ply save <since>")

    working_repo.save(since, prefix=prefix, quiet=quiet)


def main():
    if len(sys.argv) < 2:
        usage()

    cmd = sys.argv[1]
    func = globals().get('do_%s' % cmd)
    if func:
        working_repo = ply.WorkingRepo('.')
        func(working_repo, *sys.argv[2:])
    else:
        die("command '%s' not found" % cmd)


if __name__ == "__main__":
    main()
